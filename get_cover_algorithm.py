# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Cover
                                 A QGIS plugin
 This plugin implement a growing algorithm based on a land condition map and vector seeds
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-01-08
        copyright            : (C) 2024 by EEZA CSIC
        email                : arranca@eeza.csic.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'EEZA CSIC'
__date__ = '2024-01-08'
__copyright__ = '(C) 2024 by EEZA CSIC'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'


from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingException,
                       QgsProcessingFeedback,
                       QgsProcessingParameterBoolean,
                       QgsProject,
                       QgsProcessingUtils,
                       QgsVectorFileWriter,
                       QgsVectorLayer)

from qgis.PyQt.QtWidgets import QMessageBox
from qgis.utils import iface
from qgis import processing
from osgeo import gdal
import os
import numpy as np
from scipy.ndimage import binary_dilation
from qgis.gui import QgsMessageBar, QgsMessageBar
from qgis.core import Qgis
import time

# Define functions
def get_boundaries(array):
    '''
    Given a numpy.ndarray or a binary image, calculates its boundaries.

    Parameters
    ----------
    array : numpy.ndarray
        Binary image in array-like format.

    Returns
    -------
    numpy.ndarray
        Image of the boundaries in array-like format.
    '''
    struct = np.ones((3, 3), dtype=bool)

    boundaries = binary_dilation(array, structure=struct) - array

    return boundaries.astype(np.uint8)

def get_hist(array, categories):
    '''
    Given a numpy.ndarray, computes the histogram of the provided categories.

    Parameters
    ----------
    array : numpy.ndarray
      Image or vector in np.array format.
    categories : list
      List of categories.

    Returns
    -------
    numpy.ndarray
      Histogram of the image given the provided categories.
    '''

    hist, _ = np.histogram(array, bins=len(categories), range=(categories[0], categories[-1] + 1))
    return hist.astype(np.float64)

def distancia_cuerda(f1, f2):
    '''
    Given two vectors (of frequencies), computes the Orloci Cord Distance between them.
    The formula used for the calculation is: 𝐷 = √(2(1−(∑_(𝑖=1)^𝑛〖𝑦_𝑖1∙𝑦_𝑖2〗)/√(∑_(𝑖=1)^𝑛〖𝑦_𝑖1^2〗∙∑_(𝑖=1)^𝑛〖𝑦_𝑖2^2〗)))

    Parameters
    ----------
    f1 : numpy.ndarray
        Frequency vector 1.
    f2 : numpy.ndarray
        Frequency vector 2.

    Returns
    -------
    float
        Value of the Orloci Cord Distance between the two given vectors.
    '''

    denom = np.sqrt((f1 * f1).sum() * (f2 * f2).sum())
    num = (f1 * f2).sum()
    orloci_distance = np.sqrt(2 * (1 - (num / denom)))
    return orloci_distance

def orloci_coeficient(zNucleo, dRue, LIC, boundaries, categories, size):
    '''
    Given a specific seed within the seed map, it calculates the Orloci coefficient for each point along its boundary.
    To calculate the Orloci coefficient, two histograms are used: the first corresponds to the seed's histogram based
    on the land condition map, and the second corresponds to the histogram of all points within a specific-sized kernel
    using the same land condition map.

    Parameters
    ----------
    zNucleo : numpy.ndarray
        Initial seeds that will grow based on the affinity with the surroundings.
    dRue : numpy.ndarray
        Map of land condition that sets a category for each pixel.
    LIC : numpy.ndarray
        Corresponds to one specific seed inside the seed map.
    boundaries : numpy.ndarray
        Image of the boundaries.
    categories : list
        List of categories.
    size : int
        Size of the employed kernel.

    Returns
    -------
    numpy.ndarray
        Map of the Orloci Coefficient Values for the seed's boundaries.
    '''

    # Get the coordinates of the pixel boundaries
    coords = np.argwhere(boundaries)
    orloci_mask = np.zeros_like(boundaries).astype('float')

    # Calculate the seed's histogram
    dRueLic = dRue * LIC
    f1 = get_hist(dRueLic, categories)

    # Define the mask edges based on whether it is odd or even
    if size % 2 != 0:
        low = size // 2
        high = size // 2 + 1
    # When it's even, we arbitrarily center it in the bottom right corner
    else:
        low = size // 2
        high = size // 2

    for i in coords:
        x = i[0]
        y = i[1]
        dRueNxN = dRue[x-low: x+high, y-low: y+high]

        # Calculate the Orloci cord distance coefficient and assign it
        if (np.any(dRueNxN != 0)): # At least one non-zero value to compare
            f2 = get_hist(dRueNxN, categories)
            value = distancia_cuerda(f1,f2)
            orloci_mask[x][y] = value + 10  # The 10 is an arbitrary number to fix the zero bug (To fix it properly, change it to nodata)
    return orloci_mask

def growing_ameboide(zNucleo, boundaries, orloci_thresholded_mask):
    """
        Grows amoeboid regions based on the Orloci thresholded mask.
        This function combines the existing regions with the new regions determined by the Orloci thresholded mask.
        It calculates and assigns the updated areas to create the new zones.

        Parameters
        ----------
        zNucleo : numpy.ndarray
            Array representing the existing regions.
        boundaries : numpy.ndarray
            Array representing the boundaries.
        orloci_thresholded_mask : numpy.ndarray
            Mask generated by applying a threshold to the Orloci coefficients.

        Returns
        -------
        numpy.ndarray
            Updated zones resulting from the combination of existing regions and new regions based on the Orloci threshold.

        """
    newZones = zNucleo + (boundaries * orloci_thresholded_mask)
    return newZones

def escenario_cero(zNucleo, dRue, id, size, threshold, feedback = None):
    """
       Performs a growing algorthim where the process stops when no pixel is updated according to the Orloci criteria.
       Given a specific seed within the seed map, it calculates the Orloci coefficient for each point along its boundary.
       To calculate the Orloci coefficient, two histograms are used: the first corresponds to the seed's histogram based
       on the land condition map, and the second corresponds to the histogram of all points within a specific-sized kernel
       using the same land condition map.

       Parameters
       ----------
       zNucleo : numpy.ndarray
           Array representing the intial seed map.
       dRue : numpy.ndarray
           Array representing the land condition map.
       id : int
           Value identifying a specific seed within the seed map.
       size : int
           Size of the kernel used for calculate the Orloci Coefficient between the seed and its sourrandings.
       threshold : int
           Threshold value used to determine the pixels to consider based on the Orloci criteria.

       Returns
       -------
       numpy.ndarray
           Final growing map of the seed based on the land condition map and the parameters size and threshold
       """

    # Initial variables to start the loop
    LIC = (zNucleo == id).astype('int')
    newZones = LIC
    orloci_thresholded_mask = np.array([1])
    i = 0

    # Assigning the stopping condition (no pixel gets updated according to Orloci criteria)
    while not (np.all(orloci_thresholded_mask == 0)):

        i += 1

        # Verificar si se ha cancelado el proceso
        if feedback is not None and feedback.isCanceled():
            raise QgsProcessingException('--- PROCESS CANCEL BY USER ---')

        # Calculating the boundaries
        boundaries = get_boundaries(newZones)

        # Preventing extension over the edges
        boundaries = boundaries * (dRue > 0)

        # Assigning the number of categories in map condition map
        categories = np.arange(1, dRue.max()+1)

        # Calculating Orloci cord distance and assigning each value to its boundary pixel
        orloci_mask = orloci_coeficient(newZones, dRue, LIC, boundaries, categories, size)

        # Defining similar points based on the threshold
        orloci_thresholded_mask = (orloci_mask >= 10) & (orloci_mask <= 10 + threshold) # 10 fixes the bug of 0 (fix to nodata)

        # Adding new pixels to the map
        newZones = growing_ameboide(newZones, boundaries, orloci_thresholded_mask)

    return newZones

def array2raster(gdal_data, filename, raster_array):
    rows = gdal_data.RasterYSize
    cols = gdal_data.RasterXSize

    # Obtener el tipo de datos del raster de entrada
    input_data_type = gdal_data.GetRasterBand(1).DataType

    outDs = gdal.GetDriverByName("GTiff").Create(filename, cols, rows, int(1), input_data_type)
    outBand = outDs.GetRasterBand(1)

    # write the data
    outBand.WriteArray(raster_array, 0, 0)

    # Obtener el valor de NoData del raster de entrada
    input_no_data_value = gdal_data.GetRasterBand(1).GetNoDataValue()

    # Verificar si el valor de NoData es None
    if input_no_data_value is not None:
        # Convertir el valor a double antes de establecerlo
        outBand.SetNoDataValue(float(input_no_data_value))

    # Vaciar la caché, establecer el valor de NoData y calcular las estadísticas
    outBand.FlushCache()

    # georeference the image and set the projection
    outDs.SetGeoTransform(gdal_data.GetGeoTransform())
    outDs.SetProjection(gdal_data.GetProjection())



class CoverAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    INPUT_VECTOR = 'INPUT_VECTOR'
    INPUT_RASTER = 'INPUT_RASTER'
    RASTERIZE_FIELD = 'RASTERIZE_FIELD'
    SIZE = 'SIZE'
    THRESHOLD = 'THRESHOLD'
    OUTPUT_RASTERIZE = 'OUTPUT_RASTERIZE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.

        # self.addParameter(
        #     QgsProcessingParameterVectorLayer(
        #         self.INPUT_VECTOR,
        #         self.tr('Input vector layer'),
        #         [QgsProcessing.TypeVectorAnyGeometry]
        #     )
        # )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_VECTOR,
                self.tr('Input vector layer'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )


        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_RASTER,
                self.tr('Input raster layer')
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                self.RASTERIZE_FIELD,
                self.tr('Rasterize field'),
                parentLayerParameterName=self.INPUT_VECTOR,
                allowMultiple=False,
                defaultValue=None,
                type=QgsProcessingParameterField.Numeric
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.SIZE,
                self.tr('Size'),
                type=QgsProcessingParameterNumber.Integer,
                minValue=1,  # Puedes ajustar el valor mínimo según tus necesidades
                maxValue = 25,
                defaultValue=3
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.THRESHOLD,
                self.tr('Threshold: [0 - √2])'),
                type=QgsProcessingParameterNumber.Double,
                minValue=0.0,
                maxValue=np.sqrt(2),
                defaultValue=0.57317317
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT_RASTERIZE,
                self.tr('Rasterize'),
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT,
                self.tr('Output')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        # source_vector = self.parameterAsVectorLayer(parameters, self.INPUT_VECTOR, context)
        source_vector = self.parameterAsSource(parameters, self.INPUT_VECTOR, context)
        source_raster = self.parameterAsRasterLayer(parameters, self.INPUT_RASTER, context)
        rasterize_field = self.parameterAsString(parameters, self.RASTERIZE_FIELD, context)
        size_value = self.parameterAsInt(parameters, self.SIZE, context)
        threshold_value = self.parameterAsDouble(parameters, self.THRESHOLD, context)
        output_layer_path = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTERIZE, context)
        output_layer_path2 = self.parameterAsOutputLayer(parameters, self.OUTPUT, context)

        features = source_vector.getFeatures()
        polygons_ids = []
        for feature in features:
            selected_polygon_id = feature[rasterize_field]
            polygons_ids.append(selected_polygon_id)

        # Create a memory layer with the same CRS and fields as the source
        mem_layer = QgsVectorLayer(f"Polygon?crs={source_vector.sourceCrs().authid()}", "temp_layer", "memory")
        mem_layer_data = mem_layer.dataProvider()

        # Copy fields from source to memory layer
        fields = source_vector.fields()
        mem_layer_data.addAttributes(fields)
        mem_layer.updateFields()

        # Add features to memory layer
        features = list(source_vector.getFeatures())
        mem_layer_data.addFeatures(features)

        # Now use the memory layer for rasterization
        params = {
            'BURN': 0,
            'DATA_TYPE': 5,
            'EXTENT': source_raster.extent(),
            'EXTRA': '',
            'FIELD': rasterize_field,
            'HEIGHT': source_raster.rasterUnitsPerPixelX(),
            'INIT': None,
            'INPUT': mem_layer,
            'INVERT': False,
            'NODATA': 0,
            'OPTIONS': '',
            'OUTPUT': output_layer_path,
            'UNITS': 1,
            'USE_Z': False,
            'WIDTH': source_raster.rasterUnitsPerPixelY()
        }

        processing.run("gdal:rasterize", params, context=context, feedback=feedback)
        #
        # feedback.pushInfo(f"INPUT_VECTOR parameter: {parameters[self.INPUT_VECTOR]}")
        # # source_vector = self.parameterAsSource(parameters, self.INPUT_VECTOR, context)
        # feedback.pushInfo(f"Source vector valid: {source_vector is not None}")
        # # selection = source_vector.selectedFeatures()
        # # polygons_ids = []
        # # for feature in selection:
        # #     selected_polygon_id = feature[rasterize_field]
        # #     polygons_ids.append(selected_polygon_id)
        #
        # features = source_vector.getFeatures()
        # polygons_ids = []
        # for feature in features:
        #     selected_polygon_id = feature[rasterize_field]
        #     polygons_ids.append(selected_polygon_id)
        #
        # feedback.pushInfo('Selected polygons ids: '+ str(polygons_ids))
        #
        #
        # # Check if the threshold is greater than 0.6
        # if threshold_value > 0.6:
        #     # Display a warning to the user
        #     feedback.pushWarning(f" ******* THE PROCESS MAY TAKE LONGER DUE TO THE HIGH THRESHOLD VALUE OF {threshold_value}. "
        #                          f"PLEASE BE PATIENT OR CONSIDER CANCELLING THE PROCESS. *******")
        #
        #
        # feedback.setProgress(0)
        # feedback.pushInfo('Rasterizing...')
        #
        # params = {
        #     'BURN': 0,
        #     'DATA_TYPE': 5,
        #     'EXTENT': source_raster.extent(),
        #     'EXTRA': '',
        #     'FIELD': rasterize_field,
        #     'HEIGHT': source_raster.rasterUnitsPerPixelX(),
        #     'INIT': None,
        #     'INPUT': source_vector_layer,
        #     'INVERT': False,
        #     'NODATA': 0,
        #     'OPTIONS': '',
        #     'OUTPUT': output_layer_path,
        #     'UNITS': 1,
        #     'USE_Z': False,
        #     'WIDTH': source_raster.rasterUnitsPerPixelY()
        # }
        #
        # # Ejecutar la función gdal:rasterize
        # processing.run("gdal:rasterize", params, context=context, feedback=feedback)
        feedback.pushInfo('Rasterized')
        # Abir los archivos en numpy
        rasterize_vector = gdal.Open(output_layer_path)
        rasterize_vector_array = np.array(rasterize_vector.GetRasterBand(1).ReadAsArray())

        raster = gdal.Open(source_raster.source())
        raster_array = np.array(raster.GetRasterBand(1).ReadAsArray())

        # Obtener el valor de NoData del raster de entrada
        # input_no_data_value = raster.GetRasterBand(1).GetNoDataValue()

        if not polygons_ids:
            # raise QgsProcessingException('No polygons selected, please select at least one polygon!')
            polygons_ids = list(np.unique(rasterize_vector_array))
            # if input_no_data_value is not None:
            polygons_ids.remove(0)


        total_polygons = len(polygons_ids)


        global_output = np.zeros_like(raster_array, dtype=np.int32)
        for i, polygon_id in enumerate(polygons_ids):
            feedback.pushInfo('Test')
            if feedback.isCanceled():
                raise QgsProcessingException('--- PROCESS CANCEL BY USER ---')

            feedback.setProgress(i / total_polygons * 100)
            feedback.setProgressText('Processing polygon id: {}'.format(polygon_id))

            output_id = escenario_cero(rasterize_vector_array, raster_array, polygon_id, size_value, threshold_value, feedback)
            global_output += output_id

            # Actualizar barra de progreso
            QCoreApplication.processEvents()

        array2raster(raster, output_layer_path2, global_output)

        # Cerrar datasets
        rasterize_vector = None
        raster = None

        layer_details = context.layerToLoadOnCompletionDetails(output_layer_path2)
        layer_details.name = 'Output - Size: ' + str(size_value) + ' - Threshold: ' + str(threshold_value)

        # Devolver la ruta del archivo raster creado como resultado
        return {self.OUTPUT: output_layer_path2}

    def shortHelpString(self):
        """
        Return a short string describing the plugin.
        """
        return self.tr("The algorithm of the Cover plugin is based on a growth algorithm. Starting from an initial set "
                       "of seeds (vector file), an analysis of their surroundings is carried out using information "
                       "provided by the landcondition map (categorical raster file). The goal is to identify and search "
                       "for areas akin or similar to these initial seeds. To identify areas akin to the initial seeds, "
                       "a comparison process will be conducted between the original composition of the seeds and the "
                       "composition of various ground samples extracted from the surroundings of these seeds. In this "
                       "context, 'composition' refers to the histogram displaying the distribution or quantity of "
                       "pixels associated with each category of the landcondition map within a specific area or set. \n\n "
                       # "Parameters = { \n"
                       # "Input vector layer: Refers to the initial set of seeds, represented as a vector file. These seeds serve as the starting points for the algorithm. \n"
                       # "Input raster layer: Represents the landcondition map, and must be a categorical raster file.\r"
                       # "Rasterize field: Refer to a field within the input vector layer that is used for rasterization (converting the vector data into raster format for analysis) and should be unique for each seed, like an ID Tag.\n"
                       # "Size: \r"
                       # "Threshold: Defines a threshold value used in the comparison process between the original composition of the seeds and the composition of ground samples extracted from their surroundings. It likely determines the similarity between areas.\r"

                       # "Rasterize field: \n"
                       "For more information, visit: <a href='https://github.com/Aruiz99/MEDCONECTA'>Cover Documentation</a>")


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Cover'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CoverAlgorithm()




